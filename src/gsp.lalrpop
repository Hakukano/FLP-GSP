use crate::ast::{Symbol, Expr, Span, Expression, Search};

grammar;

pub GSSs: Search = {
  <stmts:Statements> => Search { stmts }
};

Statements: Vec<Expression> = {
  => Vec::new(),
  <mut st:Statements> <e:Relation> => {
    st.push(e);
    st
  }
};

Relation: Expression = {
  GroupStart <c:Comparison> GroupEnd => c,
  GroupStart <a:Relation> And <b:Relation> GroupEnd => Expression {
      span: Span::default(),
      node: Expr::And(Box::new(a), Box::new(b)),
  },
  GroupStart <a:Relation> And <b:Comparison> GroupEnd => Expression {
      span: Span::default(),
      node: Expr::And(Box::new(a), Box::new(b)),
  },
  GroupStart <a:Comparison> And <b:Relation> GroupEnd => Expression {
      span: Span::default(),
      node: Expr::And(Box::new(a), Box::new(b)),
  },
  GroupStart <a:Comparison> And <b:Comparison> GroupEnd => Expression {
      span: Span::default(),
      node: Expr::And(Box::new(a), Box::new(b)),
  },

  GroupStart <a:Relation> Or <b:Relation> GroupEnd => Expression {
      span: Span::default(),
      node: Expr::Or(Box::new(a), Box::new(b)),
  },
  GroupStart <a:Relation> Or <b:Comparison> GroupEnd => Expression {
      span: Span::default(),
      node: Expr::Or(Box::new(a), Box::new(b)),
  },
  GroupStart <a:Comparison> Or <b:Relation> GroupEnd => Expression {
      span: Span::default(),
      node: Expr::Or(Box::new(a), Box::new(b)),
  },
  GroupStart <a:Comparison> Or <b:Comparison> GroupEnd => Expression {
      span: Span::default(),
      node: Expr::Or(Box::new(a), Box::new(b)),
  },

  GroupStart Not <a:Relation> GroupEnd => Expression {
      span: Span::default(),
      node: Expr::Not(Box::new(a)),
  },
  GroupStart Not <a:Comparison> GroupEnd => Expression {
      span: Span::default(),
      node: Expr::Not(Box::new(a)),
  },
};

Comparison: Expression = {
  <a:Str> Equal <b:Str> => Expression {
      span: Span::default(),
      node: Expr::Equal(a, b),
  },
  <a:Str> EqualCI <b:Str> => Expression {
      span: Span::default(),
      node: Expr::EqualCI(a, b),
  },
  <a:Str> Greater <b:Str> => Expression {
      span: Span::default(),
      node: Expr::Greater(a, b),
  },
  <a:Str> Less <b:Str> => Expression {
      span: Span::default(),
      node: Expr::Less(a, b),
  },
  <a:Str> Wildcard <b:Str> => Expression {
      span: Span::default(),
      node: Expr::Wildcard(a, b),
  },
  <a:Str> Regex <b:Str> => Expression {
      span: Span::default(),
      node: Expr::Regex(a, b),
  },
  <a:Str> In <b:Array> => Expression {
      span: Span::default(),
      node: Expr::In(a, b),
  },
  <a:Str> IsNone => Expression {
      span: Span::default(),
      node: Expr::IsNone(a),
  },
}

Array: Vec<String> = <s:r#"\[[^\[,]*\w*(,[^\[,]*)*\]"#> => s[1..s.len() - 1]
  .split(",")
  .map(|a| a.trim().to_string())
  .collect();

Str: String = <s:r#"`[^`]*`"#> => s[1..s.len() - 1].to_string();

GroupStart: Symbol = "(" => Symbol::GroupStart;

GroupEnd: Symbol = ")" => Symbol::GroupEnd;

And: Symbol = "&" => Symbol::And;

Or: Symbol = "|" => Symbol::Or;

Not: Symbol = "!" => Symbol::Not;

Equal: Symbol = "=" => Symbol::Equal;

EqualCI: Symbol = "~" => Symbol::EqualCI;

Greater: Symbol = ">" => Symbol::Greater;

Less: Symbol = "<" => Symbol::Less;

Wildcard: Symbol = "*" => Symbol::Wildcard;

Regex: Symbol = "$" => Symbol::Regex;

In: Symbol = "?" => Symbol::In;

IsNone: Symbol = "-" => Symbol::IsNone;
